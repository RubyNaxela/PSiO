<!DOCTYPE html>
<!-- saved from url=(0086)http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Lab 04 - Pliki, wyrażenia regularne</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ff0000;
      font-weight: bold;
    }

    /* Alert */
    code span.an {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #7d9029;
    }

    /* Attribute */
    code span.bn {
      color: #40a070;
    }

    /* BaseN */
    code span.bu {}

    /* BuiltIn */
    code span.cf {
      color: #007020;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4070a0;
    }

    /* Char */
    code span.cn {
      color: #880000;
    }

    /* Constant */
    code span.co {
      color: #60a0b0;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #ba2121;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #902000;
    }

    /* DataType */
    code span.dv {
      color: #40a070;
    }

    /* DecVal */
    code span.er {
      color: #ff0000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #40a070;
    }

    /* Float */
    code span.fu {
      color: #06287e;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #007020;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #666666;
    }

    /* Operator */
    code span.ot {
      color: #007020;
    }

    /* Other */
    code span.pp {
      color: #bc7a00;
    }

    /* Preprocessor */
    code span.sc {
      color: #4070a0;
    }

    /* SpecialChar */
    code span.ss {
      color: #bb6688;
    }

    /* SpecialString */
    code span.st {
      color: #4070a0;
    }

    /* String */
    code span.va {
      color: #19177c;
    }

    /* Variable */
    code span.vs {
      color: #4070a0;
    }

    /* VerbatimString */
    code span.wa {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */
  </style>
  <link rel="stylesheet" href="css/github-markdown.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/rubynaxela-darkmode.css">
  <script type="text/javascript" src="js/rubynaxela-navbar.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="icon" type="image/x-icon" href="http://jug.put.poznan.pl/lab-psio/_static/favicon.ico">
</head>

<body>
  <main class="markdown-body">
    <header id="title-block-header">
      <h1 class="title">Lab 04 - Pliki, wyrażenia regularne</h1>
    </header>
    <h1 id="lab-04---pliki-wyrażenia-regularne">Lab 04 - Pliki, wyrażenia regularne</h1>
    <h2 id="wyrażenia-regularne">Wyrażenia regularne</h2>
    <p>Wyrażenia regularne pozwalają tworzyć uogólnione wzorce a następnie znajdować je w tekście (search) lub sprawdzać
      czy tekst spełnia kryteria wzorca (match). Zadanie to można również zrealizować stosujące pętle i instrukcje
      warunkowe jednak taki kod będzie skomplikowany i mało ekspresywny.</p>
    <h3 id="podstawowe-symbole-uogólniające">Podstawowe symbole uogólniające</h3>
    <p>W wyrażeniu regularnym mogą pojawić się następujące elementy służące go uogólnionej reprezentacji znaku (więcej
      informacji dotyczących składni można znaleźć <a
        href="http://www.cplusplus.com/reference/regex/ECMAScript/">tutaj</a>:</p>
    <table>
      <thead>
        <tr class="header">
          <th>Symbol</th>
          <th>Znaczenie</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><code>\w</code></td>
          <td>zastępuje dowolny znak alfanumeryczny tzn. a-z, A-Z,0-9, _</td>
        </tr>
        <tr class="even">
          <td><code>\d</code></td>
          <td>zastępuje dowolną cyfrę: 0-9</td>
        </tr>
        <tr class="odd">
          <td><code>\s</code></td>
          <td>oznacza znak białej spacji (tzn. spacja lub tabulator)</td>
        </tr>
        <tr class="even">
          <td><code>\W</code> lub <code>\D</code> <code>\S</code></td>
          <td>zastępuje dowolny znak inny niż <code>\w</code> lub <code>\d</code> lub <code>\s</code></td>
        </tr>
        <tr class="odd">
          <td><code>[A-Z1-3]</code></td>
          <td>zastępuje dowolny znak ze zbioru znaków wymienionego w wyrażeniu. W przykładzie dowolny znak który jest
            wielką literą (A-Z) lub cyfrą 1,2 lub 3</td>
        </tr>
        <tr class="even">
          <td><code>[^1-3]</code></td>
          <td>zastępuje dowolny znak nie należący do wskazanego zbioru. W przykładzie dowolny znak różny od cyfr 1,2,3
          </td>
        </tr>
        <tr class="odd">
          <td><code>.</code></td>
          <td>Zastępuje dowolny znak poza znakiem końca linii (<code>\n</code>)</td>
        </tr>
        <tr class="even">
          <td><code>(sth)</code></td>
          <td>Wyodrębnia grupę opisaną podwzorcem <code>sth</code>, taki wzorzec może wykorzystywać wszystkie symbole
            uogólniające wyrażenia regularnego.</td>
        </tr>
        <tr class="odd">
          <td><code>(PO)|(PZ)</code></td>
          <td><code>|</code> oznacza alternatywę dwóch wzorców/znaków uogólniających. Przy dopasowaniu wzorca element
            jest uznawany jako pasujący, gdy co najmniej jedna z grup/znaków została poprawnie dopasowana</td>
        </tr>
        <tr class="even">
          <td><code>^</code></td>
          <td>oznacza początek linii tekstu, stąd dopasowanie następuje gdy następujące za tym znakiem wyrażenie
            znajduje się na początku linii</td>
        </tr>
        <tr class="odd">
          <td><code>$</code></td>
          <td>oznacza koniec linii (<code>\n</code>), stąd wyrażenie poprzedzające ten znak musi znajdować się na końcu
            linii.</td>
        </tr>
      </tbody>
    </table>
    <hr>
    <h4 id="zadanie-">🛠🔥Zadanie 🛠🔥</h4>
    <p>Do sprawdzenia działania przykładów możesz użyć strony <a href="https://regex101.com/">regex101.com</a>. Wejdź na
      podaną stronę i zapoznaj się z jej działaniem, następnie wykonaj przedstawione poniżej zadania 1-3:</p>
    <ol type="1">
      <li>
        <p>Kod pocztowy w Polsce jest reprezentowany za pomocą wyrażenia (przetestuj jego działanie podając prawidłowe i
          nieprawidłowe kody): <code>\d\d-\d\d\d</code></p>
        <p>W wyrażeniu tym cyfry są oznaczone wzorcem, natomiast kreska jest konkretnym znakiem (elementem
          nieuogólnionym).</p>
      </li>
      <li>
        <p>Jeśli wyrażenie regularne miałoby weryfikować np. czy numer rejestracyjny pochodzi z Poznania i czy jest to
          numer rejestracyjny, może mieć postać: <code>PO[A-Z0-9][A-Z0-9][A-Z0-9][A-Z0-9][A-Z0-9]</code></p>
      </li>
      <li>
        <p>Spróbuj napisać pojedynczy wzorzec, który będzie pasował zarówno do numerów rejestracyjnych rozpoczynających
          się na <code>PO</code> jak i na <code>PZ</code>.</p>
      </li>
    </ol>
    <hr>
    <h3 id="kwantyfikatory">Kwantyfikatory</h3>
    <p>Dla powtarzających się elementów wzorca możemy określić reguły dotyczące ich wystąpień:</p>
    <p>| Symbol | Znaczenie| |----|---| | <code>*</code> | Dany element występuje 0 lub więcej razy|
      |<code>+</code>|Dany element występuje 1 lub więcej razy| |<code>?</code>|Dany element występuje 0 lub 1 razy|
      |<code>{n}</code>|Dany element występuje dokładnie n razy| |<code>{n,}</code>|Dany element występuje
      <code>n</code> lub więcej razy| |<code>{min,max}</code>|Dany element występuje <code>min</code>, nie więcej niż
      <code>max</code> razy|
    </p>
    <p><strong>Uwaga</strong>: jeśli w danym wzorcu chcemy wykorzystać któryś z w/w kwantyfikatorów lub symboli
      uogólniających jako zwykły znak należy go poprzedzić backslashem np.: <code>\.</code> zostanie potraktowana jako
      znak kropki a nie oznaczenie dowolnego znaku.</p>
    <hr>
    <h4 id="zadanie-cd-">🛠🔥Zadanie cd 🛠🔥</h4>
    <ol start="4" type="1">
      <li>Stosując kwantyfikatory spróbuj uogólnić zarówno wzorce dla kodu pocztowego jak i numeru rejestracyjnego,
        wiedząc, że: np. <code>\w+</code> jest wzorcem dla wyrazu (gdzie znak alfanumeryczny występuje 1 lub więcej
        razy)</li>
      <li>Kawantyfikatory mogą być używane zarówno do pojedynczych symboli uogólniających jak i grup np.
        :<code>(sth)+</code>. Spróbuj napisać wzorzec, który sprawdzi czy dany ciąg jest numerem telefonu. W wersji
        prostszej wystarczy że wyrażenie będzie w stanie poprawnie rozpoznać cztery pierwsze podane poniżej przykłady. W
        wersji trudniejszej (dla chętnych) spróbuj uwzględnić żę numer ten może, ale nie musi być podawany z prefiksem
        kraju lub numer kierunkowy miejscowości może być podany w nawiasie. Wzorzec powinien akceptować następujące
        formy numeracji:</li>
    </ol>
    <pre><code>      12-34-56-789
      12 34 56 789
      12 429 34 30
      123-45-67-89
      0048123456789
      +48123456789
      +48 123-45-67-89
      (032) 6700327</code></pre>
    <p>Ciągi w których występuje więcej cyfry lub dodatkowe znaki nie powinny być akceptowane</p>
    <ol start="6" type="1">
      <li>Sprawdź działanie powyższego wyrażenia wklejając wyniki wyszukiwania ze strony google (np. fraza wyszukiwania:
        "numery telefonów filie") lub skorzystaj z przykładowego <a
          href="http://jug.put.poznan.pl/lab-psio/_resources/04/numeryTelefonowGoogle.html">pliku html</a>. Plik możesz
        obejrzeć w przeglądarce, następnie wyświetl i skopiuj jego źródło i wklej je do <a
          href="https://regex101.com/">regex101</a>. Spróbuj zrozumieć dlaczego prócz numerów telefonów jako wyniki
        dopasowanie pojawiły się również inne elementy i dlaczego część numerów nie została znaleziona. Na tym etapie
        nie ma konieczności wprowadzania istotnych modyfikacji wzorca (ale możesz wprowadzić kilka zmian zwiększających
        skuteczność dopasowania), będziesz to robił w ramach zadania domowego.</li>
    </ol>
    <p><em><strong>Uwaga do zadania 6:</strong></em> Pamiętaj, że stworzenie wzorca, który w udostępnionym pliku
      znajdzie wszystkie numery telefonu, a jednocześnie nie wykryje innych błędnych dopasowań jest trudne do wykonania
      z uwagi na występowanie w tym pliku dodatkowych informacji w innym kodowaniu, nazw linków i funkcji JavaScript.
      Poprawne odróżnienie numeru telefonu od innych kombinacji cyfr występujących w kodzie jest możliwe tylko wtedy gdy
      uwzględnimy kontekst, w którym pojawia się dany ciąg. Stąd np. numery telefonów powinny być szukane tylko w części
      pliku, w którym pojawiają się wyniki wyszukiwania a nie w obrębie całego kodu strony. Czy jesteś w stanie
      zidentyfikować w pliku początek i koniec sekcji, w której znajdują się wyniki wyszukiwań. Spróbuj w tym celu w
      przeglądarce wykorzystać narzędzie inspekcji.</p>
    <!-- 7. \W{2}(0?|\+\d{2}|00\d{2})(((-|\s|(<[^>]+>)|[\(\)])*\d){9})\D -->

    <hr>
    <h3 id="stdregex">std::regex</h3>
    <p>Wyrażenia regularne w języku C++ (w STL w pliku nagłówkowym <code>&lt;regex&gt;</code>) są zgodne z składnią
      ECMAScript (opisaną powyżej), mogą być również wykorzystywane w innych językach programowania i części edytorów
      tekstu.</p>
    <p>Przy używaniu ich w języku C++ należy pamiętać żeby wszystkie wystąpienia znaku <code>\</code> zastąpić podwójnym
      backslashem <code>\\</code> np. <code>\\w</code> lub poprzedź tekst wyrażenia regularnego znakiem
      <code>R"(text)"</code> np. <code>std::regex re(R"(\d*)")</code> - zwróć uwagę na dodatkowe nawiasy okrągłe, w
      których należy umieścić całe wyrażenie.
    </p>
    <h3 id="stdregex_match">std::regex_match</h3>
    <p>Funkcja służy do zweryfikowania czy ciąg przekazany jako argument jest w pełni zgodny ze wzorcem. Uruchom i
      przeanalizuj poniższy kod:</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>regex re(<span class="st">R"(\d+)"</span>);;</span>
<span id="cb2-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>smatch m;</span>
<span id="cb2-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string text = <span class="st">"1234"</span>;</span>
<span id="cb2-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> res = <span class="bu">std::</span>regex_match(text, m, re); <span class="co">//zwróci wartość true</span></span>
<span id="cb2-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb2-5" aria-hidden="true" tabindex="-1"></a>text = <span class="st">"1234m"</span>;</span>
<span id="cb2-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb2-6" aria-hidden="true" tabindex="-1"></a>res = <span class="bu">std::</span>regex_match(text, m, re); <span class="co">//zwróci wartość false</span></span></code></pre>
    </div>
    <h3 id="stdregex_search">std::regex_search</h3>
    <p>Funkcja służy do zweryfikowania czy pewien podciąg jest zgodny ze wzorcem. Uruchom i przeanalizuj poniższy kod:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>regex re(<span class="st">R"(\d+)"</span>);</span>
<span id="cb3-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>smatch m;</span>
<span id="cb3-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string text = <span class="st">"1234"</span>;</span>
<span id="cb3-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> res = <span class="bu">std::</span>regex_search(text, m, re); <span class="co">//zwróci wartość true</span></span>
<span id="cb3-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb3-5" aria-hidden="true" tabindex="-1"></a>text = <span class="st">"1234m 78910"</span>;</span>
<span id="cb3-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb3-6" aria-hidden="true" tabindex="-1"></a>res = <span class="bu">std::</span>regex_search(text, m, re); <span class="co">//zwróci wartość true i zwróci do m pierwszy pasujący podciąg czyli 1234</span></span></code></pre>
    </div>
    <p>Funkcja znajduje i dopasowuje tylko pierwszy pasujący podciąg. Zmienna wyniku <code>std::smatch m</code> jest
      kolekcją (podobną do wektora) elementów typu <code>string</code>. Jeśli nie znaleziono dopasowania to;</p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb4-1" aria-hidden="true" tabindex="-1"></a>m.ready() == <span class="kw">true</span></span>
<span id="cb4-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb4-2" aria-hidden="true" tabindex="-1"></a>m.empty() == <span class="kw">true</span></span>
<span id="cb4-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb4-3" aria-hidden="true" tabindex="-1"></a>m.size() == <span class="dv">0</span></span></code></pre>
    </div>
    <p>jeśli znaleziono dopasowanie to: |Atrybut|Wartość lub opis| |---|---| |m.ready()|true |m.empty()|false
      |m.size()|liczba istniejących w wyrażeniu liczba grup + 1 |m.prefix()| <code>std::string</code> zawierający część
      tekstu poprzedzającą dopasowany wzorzec |m.suffix()| <code>std::string</code> zawierający część tekstu następującą
      po dopasowanym wzorcu |m[0]| <code>std::string</code> zawierający tekst dopasowany wg wzorca |m[n]|
      <code>std::string</code> zawierający tekst dopasowanej <em>n</em>-tej grupy umieszczonej we wzorcu (gdzie
      <em>n</em> &lt;= liczbie grup) |m[n].matched()| true/false - w zależności od tego czy dana grupa została
      dopasowana (nie każda grupa, poprawnie dopasowanego wzorca, musi zostać dopasowana np. <code>(sth)\|(sth)</code> -
      w wyrażeniu są 2 grupy, dla dopasowania wzorca wystarczy, że zostanie dopasowana tylko jedna z nich)
    </p>
    <p>Żeby znaleźć w tekście więcej (wszystkie) pasujące do wzorca ciągi funkcję <code>std::regex_search</code> można
      wywoływać cyklicznie, podając jako tekst <code>m.sufix()</code> z ostatnio znalezionego dopasowania. Przeanalizuj
      poniższy przykład zawierający użycie grup i iterowane przeszukiwanie tekstu:</p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>endl &lt;&lt; <span class="st">"regex_search all"</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb5-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string log(<span class="st">R"(</span></span>
<span id="cb5-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="st">      Speed: 366</span></span>
<span id="cb5-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="st">      Mass: 35</span></span>
<span id="cb5-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="st">      Speed: 378</span></span>
<span id="cb5-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="st">      Mass: 32</span></span>
<span id="cb5-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="st">      Speed: 400</span></span>
<span id="cb5-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="st">      Mass: 30)"</span>);</span>
<span id="cb5-9"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>regex re(<span class="st">R"(Speed:\s(\d+))"</span>);</span>
<span id="cb5-10"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>smatch sm;</span>
<span id="cb5-11"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (regex_search(log, sm, re)) {</span>
<span id="cb5-12"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-12" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cout &lt;&lt; sm[<span class="dv">0</span>] &lt;&lt; <span class="bu">std::</span>endl; <span class="co">//Podciąg dla którego wzorzec jest w pełni dopasowany</span></span>
<span id="cb5-13"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-13" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Group 1: "</span> &lt;&lt; sm[<span class="dv">1</span>] &lt;&lt; <span class="bu">std::</span>endl &lt;&lt; <span class="bu">std::</span>endl; <span class="co">//grupa nr 1 (\d*)</span></span>
<span id="cb5-14"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-15" aria-hidden="true" tabindex="-1"></a>      log = sm.suffix(); <span class="co">//przycięcie napisu do przeszukania</span></span>
<span id="cb5-16"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb5-16" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p><strong>Uwaga</strong>: iterowane przeszukiwanie można również zrealizować przy pomocy iteratora <a
        href="https://en.cppreference.com/w/cpp/regex/regex_iterator"><code>std::regex_iterator</code></a> sprawdź go w
      dokumentacji.</p>
    <hr>
    <h4 id="zadanie-cd--1">🛠🔥Zadanie cd 🛠🔥</h4>
    <ol start="7" type="1">
      <li>
        <p>Spróbuj napisać program, który wykorzystuje wyrażenia regularne stworzone w zadaniu 4 i używając
          <code>std::regex_match</code> przeparsuj następującą kolekcję numerów rejestracyjnych zwracając te, które
          pochodzą z poznania (PO) lub powiatu poznańskiego (PZ):
        </p>
        <div class="sourceCode" id="cb6">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; lines = {<span class="st">"PO12345"</span>, <span class="st">"PO 12345"</span>, <span class="st">"PZ973ND"</span>, <span class="st">"WE20456"</span>};</span></code></pre>
        </div>
      </li>
    </ol>
    <hr>
    <h2 id="pliki">Pliki</h2>
    <p>W Lab02 zapoznałeś się z wczytywaniem plików z danymi w formie tabelarycznej. W aktualnym ćwiczeniu przedstawiono
      dodatkowe informacje przydatne przy realizacji zadań.</p>
    <p>Aby uzyskać dostęp do plików bez podawania ścieżki bezwzględnej, należy umieścić otwierane pliki w folderze
      uruchamiania programu. W przypadku uruchamiania programu z poziomu Qt Creator domyślnym folderem uruchomieniowym
      jest folder kompilacji znajdujący się <em>obok</em> folderu projektu, o nazwie:
      <em>build-&lt;project_name&gt;-&lt;kit_name&gt;-&lt;build_type&gt;</em>, np.
      <em>build-regex-Desktop_Qt_5_13_2_MinGW_64_bit-Debug</em>.
    </p>
    <h3 id="wczytanie-pliku-wyraz-po-wyrazie">Wczytanie pliku wyraz po wyrazie</h3>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>fstream input_file(<span class="st">"filename"</span>, <span class="bu">std::</span>ios<span class="bu">::</span>in);</span>
<span id="cb7-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; words;</span>
<span id="cb7-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (input_file.is_open()) {</span>
<span id="cb7-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> (!input_file.eof()) {</span>
<span id="cb7-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>string word;</span>
<span id="cb7-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-6" aria-hidden="true" tabindex="-1"></a>            input_file &gt;&gt; word; <span class="co">//wczytuje słowo</span></span>
<span id="cb7-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-7" aria-hidden="true" tabindex="-1"></a>            words.emplace_back(word); <span class="co">//dodaje słowo do kolekcji</span></span>
<span id="cb7-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-8" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb7-9"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb7-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <h3 id="wczytanie-całego-pliku-do-pamięci">Wczytanie całego pliku do pamięci</h3>
    <p>Poniższy kod wczytuje całą zawartość pliku tekstowego do zmiennej <code>std::string full_text</code>.
      Przeanalizuj kod i wykorzystaj gdy będzie to potrzebne:</p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>fstream input_file(<span class="st">"filename"</span>, <span class="bu">std::</span>ios<span class="bu">::</span>in);</span>
<span id="cb8-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(input_file.is_open()){</span>
<span id="cb8-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb8-3" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>stringstream str_stream;</span>
<span id="cb8-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb8-4" aria-hidden="true" tabindex="-1"></a>      str_stream &lt;&lt; input_file.rdbuf(); <span class="co">//przepisuje zawartość pliku do strumienia</span></span>
<span id="cb8-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb8-5" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>string full_text = str_stream.str(); <span class="co">//zapisuje całą zawartość strumienia do std::string</span></span>
<span id="cb8-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb8-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p><strong>Uwaga</strong>: kod wymaga dodatkowych plików nagłówkowych <code>&lt;fstream&gt;</code>,
      <code>&lt;sstream&gt;</code>
    </p>
    <h3 id="zapisywanie-danych-do-pliku">Zapisywanie danych do pliku</h3>
    <p>Zapis danych do pliku tekstowego jest analogiczny do wyświetlania danych na konsoli, z tą różnicą że dane
      zapisywane są do innego strumienia. Poniższy kod zapisuje kolejne wartości funkcji sinus oraz wartość argumentu:
    </p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>fstream output(<span class="st">"filename"</span>, <span class="bu">std::</span>ios<span class="bu">::</span>out);</span>
<span id="cb9-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (output.is_open()) {</span>
<span id="cb9-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (<span class="dt">double</span> x = <span class="dv">0</span>; x &lt; <span class="dv">10</span>; x += <span class="fl">0.1</span>) {</span>
<span id="cb9-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-4" aria-hidden="true" tabindex="-1"></a>            output &lt;&lt; x &lt;&lt; <span class="st">";"</span> &lt;&lt; sin(x) &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb9-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-5" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb9-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-6" aria-hidden="true" tabindex="-1"></a>      output.close();</span>
<span id="cb9-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb9-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p><strong>Uwaga</strong>: Pamiętaj że po zakończeniu zapisu należy plik zamknąć, w innym przypadku część danych
      może się nie zapisać.</p>
    <hr>
    <h4 id="zadanie-cd--2">🛠🔥Zadanie cd 🛠🔥</h4>
    <ol start="8" type="1">
      <li>Wczytaj <a href="http://jug.put.poznan.pl/lab-psio/_resources/04/numeryTelefonowGoogle.html">plik</a> z
        wynikami wyszukiwania numerów telefonów z Google i używając <code>std::regex_search</code> lub
        <code>std::regex_iterator</code> wyświetl wszystkie numery pasujące do stworzonego wcześniej wzorca.
      </li>
    </ol>
    <hr>
    <h2 id="stdpairstdtuple">std::pair/std::tuple</h2>
    <p>W przypadku operacji na plikach często przechowuje się pary informacji np. nazwisko i ocenę studenta, symbol i
      kurs waluty. Te informacje mogą być reprezentowane jako struktura, ale dla prostych elementów (par elementów) nie
      zawsze ma sens definiowanie nowego typu strukturalnego (z nazwanymi polami). Możliwe jest wtedy wykorzystanie
      kontenera STL typu <code>std::pair</code>, który jest wzorcem struktury o dwóch polach: <code>first</code> i
      <code>second</code>.
    </p>
    <p>Np. definicja pary przechowującej kurs waluty może mieć postać:</p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">//para z wartościami domyślnymi "" i 0:</span></span>
<span id="cb10-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair&lt;<span class="bu">std::</span>string, <span class="dt">double</span>&gt; exchange_rate_empty;</span>
<span id="cb10-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">//zmiana wartości pary:</span></span>
<span id="cb10-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-5" aria-hidden="true" tabindex="-1"></a>exchange_rate_empty = {<span class="st">"EUR"</span>, <span class="fl">4.5</span>}; <span class="co">// lub std::make_pair&lt;string,double&gt;("EUR",4.5);</span></span>
<span id="cb10-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">//definicja para z zainicjowaną dwoma wartościami:</span></span>
<span id="cb10-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair&lt;<span class="bu">std::</span>string, <span class="dt">double</span>&gt; exchange_rate_usd(<span class="st">"usd"</span>,<span class="fl">4.10</span>);</span></code></pre>
    </div>
    <p>Odwołanie się do pól pary może mieć postać:</p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">//odwołanie się do pól first i second</span></span>
<span id="cb11-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"currency: "</span> &lt;&lt; exchange_rate_usd.first &lt;&lt; <span class="st">" - rate: "</span> &lt;&lt; exchange_rate_usd.second;</span>
<span id="cb11-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">//lub z użyciem structured binding od C++17</span></span>
<span id="cb11-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span>[currency, rate] = exchange_rate_usd;</span>
<span id="cb11-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"currency: "</span> &lt;&lt; currency &lt;&lt; <span class="st">" - rate: "</span> &lt;&lt; rate;</span></code></pre>
    </div>
    <p>Użycie <code>auto[currency, rate] = exchange_rate_usd;</code> w domyślnie skonfigurowanym środowisku spowoduje
      pojawienie się <em>Warning</em> w czasie kompilacji. Aby korzystać z standardu C++17 należy wyedytować plik
      <code>.pro</code> projektu i zamienić:
    </p>
    <pre class="qmake"><code>CONFIG += console c++11</code></pre>
    <p>na:</p>
    <pre class="qmake"><code>CONFIG += console c++17</code></pre>
    <p>Następnie klikamy prawym klawiszem na nazwę projektu i wybieramy <em><strong>Run qmake</strong></em>.</p>
    <p>Krotka (<code>std::tuple</code>), jest wzorcem podobnym do pary, ale może się składać się z większej niż 2 liczby
      pól. Krotka/para może być wykorzystana np. do zwracania przez funkcję więcej niż jednej wartości:</p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>tuple&lt;<span class="dt">char</span>, <span class="dt">int</span>, <span class="dt">bool</span>&gt; mytuple() {</span>
<span id="cb14-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> a = <span class="ch">'a'</span>;</span>
<span id="cb14-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = <span class="dv">123</span>;</span>
<span id="cb14-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> b = <span class="kw">true</span>;</span>
<span id="cb14-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {a, i, b};<span class="co">// lub std::make_tuple(a, i, b);</span></span>
<span id="cb14-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb14-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>Wywołanie funkcji z wykorzystaniem structured binding może mieć postać:</p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> [a, i, b] = mytuple();</span></code></pre>
    </div>
    <hr>
    <h2 id="stdmap">std::map</h2>
    <p>Mapa jest tablicą asocjacyjną przechowującą dane jako parę klucza i wartości zorganizowaną w formie drzewa
      binarnego (BST) (ang. binary search tree)). Oznacza to, że kontener jest posortowanym (wg klucza) zbiorem danych,
      w którym może istnieć wyłącznie jedna wartość przypisana do danego klucza.</p>
    <p>Elementem kontenera jest para taka że: <code>std::pair&lt;typ_klucza,typ_wartości&gt;</code> a definicja
      kontenera ma postać:</p>
    <h3 id="definiowanie-mapy">Definiowanie mapy</h3>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>map&lt;<span class="dt">key_type</span>,<span class="dt">value_type</span>&gt; container_name;</span></code></pre>
    </div>
    <p>np.</p>
    <div class="sourceCode" id="cb17">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>map&lt;<span class="bu">std::</span>string, <span class="dt">int</span>&gt; word_statistics;</span></code></pre>
    </div>
    <h3 id="dodawanie-elementu-do-mapyodwoływanie-się-do-elementu">Dodawanie elementu do mapy/Odwoływanie się do
      elementu</h3>
    <p>Element dodawany do mapy musi być umieszczony w ściśle określonym miejscu wynikającym z organizacji BST. Stąd
      kontener ten nie posiada metody <code>emplace_back</code>, tylko metodę <code>emplace</code> i metodę
      <code>try_emplace</code>.
    </p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb18-1" aria-hidden="true" tabindex="-1"></a>word_statistics.emplace(<span class="st">"the"</span>,<span class="dv">1</span>); <span class="co">//dodaje słowo "the" i przyporządkowaną mu wartość: 1 odpowiada to dodaniu pary: make_pair&lt;std:string, int&gt;("the",1)</span></span></code></pre>
    </div>
    <p>Element może również zostać dodany do mapy przez odwołanie się do klucza z wykorzystaniem operatora indeksowania:
    </p>
    <div class="sourceCode" id="cb19">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb19-1" aria-hidden="true" tabindex="-1"></a>word_statistics[<span class="st">"the"</span>] = <span class="dv">1</span>; <span class="co">//dodaje słowo "the" i przyporządkowaną mu wartość: 1// jeśli element istnieje wartość zostanie nadpisana</span></span></code></pre>
    </div>
    <p>Ten sam sposób może być użyty do odczytu wartości przypisanej do danego klucza:</p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; word_statistics[<span class="st">"the"</span>]; <span class="co">//zostanie wartość 1</span></span>
<span id="cb20-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; word_statistics[<span class="st">"computer"</span>]; <span class="co">//element nie istnieje, zostanie utworzony i przypisana zostanie wartość domyślna dla int -&gt;0</span></span></code></pre>
    </div>
    <p>Odwołanie się do elementu tablicy asocjacyjnej po kluczu pozwala na odczyt wartości, jednak w przypadku gdy taki
      klucz nie istnieje, do mapy zostanie dodany nowy element i zainicjowany wartością domyślną, a następnie wartość ta
      zostanie zwrócona. Czasem jest to niepożądane stąd żeby temu zapobiec, należałoby sprawdzić czy element istnieje
      używając np. metody <a href="https://en.cppreference.com/w/cpp/container/map/find"><code>find</code></a> lub <a
        href="https://en.cppreference.com/w/cpp/container/map/contains"><code>contains</code></a> (C++20). Można również
      użyć metody <code>at</code>, która w przypadku nie znalezienia elementu generuje wyjątek
      <code>std::out_of_range</code>.
    </p>
    <div class="sourceCode" id="cb21">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string word2find = <span class="st">"elephant"</span>;</span>
<span id="cb21-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>{</span>
<span id="cb21-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> val = word_statistics.at(word2find);</span>
<span id="cb21-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="cf">catch</span>(<span class="bu">std::</span>out_of_range e){</span>
<span id="cb21-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-6" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb21-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb21-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>jeśli nie chcesz używać wyjątków do odnalezienia elementu w mapie możesz wykorzystać <code>std::map::find</code>:
    </p>
    <div class="sourceCode" id="cb22">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string word2find = <span class="st">"elephant"</span>;</span>
<span id="cb22-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> search = word_statistics.find(word2find); <span class="co">//zwraca iterator</span></span>
<span id="cb22-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(search != word_statistics.end()) {</span>
<span id="cb22-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> val = search-&gt;second; <span class="co">//znaleziona wartość </span></span>
<span id="cb22-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> {</span>
<span id="cb22-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-7" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cout &lt;&lt; <span class="st">"Element nie został znaleziony"</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb22-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb22-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <h3 id="iterowanie-po-mapie">Iterowanie po mapie</h3>
    <p>Mapa jest kontenerem STL, stąd iterowanie po kontenerze odbywa się, tak jak w przypadku wektorów i list, przy
      pomocy iteratorów lub range-based for loop. Pierwszy element w kontenerze (<code>*word_statistics.begin()</code>)
      jest najmniejszy (w porządku klucza) a ostatni element jest największy. Należy pamiętać, że elementem kontenera
      jest para.</p>
    <div class="sourceCode" id="cb23">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(<span class="kw">auto</span> it = word_statistics.begin(); it != word_statistics.end(); it++){ <span class="co">//gdzie it jest iteratorem typu: std::map&lt;std::string,int&gt;::iterator</span></span>
<span id="cb23-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-2" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cout&lt;&lt; it-&gt;first &lt;&lt; <span class="st">" - "</span> &lt;&lt; it-&gt;second&lt;&lt; <span class="bu">std::</span>endl; <span class="co">// wyświetla klucz i wartość poszczególnych elementów listy</span></span>
<span id="cb23-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb23-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="co">//lub z wykorzystaniem structure binding i for range loop</span></span>
<span id="cb23-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(<span class="kw">auto</span> [word, frequency] : word_statistics){ <span class="co">// rzutowanie klucza i wartości elementu na zmienną word (klucz) i frequency (wartość)</span></span>
<span id="cb23-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-7" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>cout&lt;&lt; word &lt;&lt; <span class="st">" - "</span> &lt;&lt; frequency &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb23-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2004%20-%20Pliki,%20wyra%bfenia%20regularne.html#cb23-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <h2 id="zadanie-końcowe-">Zadanie końcowe 🛠🔥</h2>
    <ol type="1">
      <li>Wczytaj <a href="http://jug.put.poznan.pl/lab-psio/_resources/04/license.txt">plik</a> zawierający licencję
        GNU, w <code>std::map</code> umieść wyrazy wraz z częstością ich występowania:
        <ul>
          <li>Wczytuj wyraz po wyrazie i dodawaj element do mapy inkrementując wartość o 1 (będzie ona stanowiła licznik
            liczby wystąpień danego wyrazu).</li>
          <li>Po zakończeniu wczytywania wyświetl statystykę wyrazów z liczbą ich wystąpień.</li>
          <li>Używając algorytmu <code>std::copy</code> przekopiuj dane z mapy do
            <code>std::vector&lt;std::pair&lt;std::string,int&gt;&gt;</code> i posortuj słowa po częstości wystąpień.
            <strong>PODPOWIEDŹ</strong>: Przed skorzystaniem z <code>std::copy</code> zobacz jak wygląda przykład
            (<em>Example</em>) na stronie referencyjnej <a
              href="https://en.cppreference.com/w/cpp/algorithm/copy"></a><a
              href="https://en.cppreference.com/w/cpp/algorithm/copy">https://en.cppreference.com/w/cpp/algorithm/copy</a>.
          </li>
          <li>Zapisz wynik do pliku.</li>
          <li>Zmodyfikuj program tak, aby używając wyrażeń regularnych wybrać z wczytywanego tekstu tylko słowa,
            usuwając znaki, które nie są literami (np. znaki interpunkcyjne).</li>
          <li>Używając algorytmu <code>std::transform</code> i predykatu <code>std::tolower</code> przed dodaniem słowa
            do mapy zmień wielkość liter tak by w mapie umieszczone były unikalne słowa pisane małymi literami.</li>
        </ul>
      </li>
    </ol>
    <hr>
    <h2 id="zadanie-domowe-">Zadanie domowe 🏠🔥</h2>
    <h4 id="zadanie-1">Zadanie 1</h4>
    <p>Wczytaj pliki zawierające wyniki wyszukiwania stron internetowych, m.in. plik dla którego poprzednio
      wyodrębniałeś telefony (lista plików zawierająca wyniki wyszukiwań w Google: <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/04/numeryTelefonowGoogle.html">plik1</a>, <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/04/wypozyczalnie_tel_biblioteki_google.html">plik2</a> , <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/04/wypozyczalnie_tel_biblioteki_google2.html">plik3</a>, <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/04/wypozyczalnie_tel_biblioteki_google3.html">plik4</a>.
      Zauważ, że telefon wizualnie skojarzony jest z hyperlinkiem (umieszczonym w nagłówku wyniku wyszukiwania)
      prowadzącym na stronę, na której został opublikowany. np.
      <code>https://www.biblioteka.wroc.pl/filie/filia-nr-7</code>. Łatwiej to zauważyć gdy np. w Google Chrome, na
      podglądzie strony, wybierzesz funkcję inspect <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/04/google_inspect.png">preview</a>, wtedy możesz zobaczyć
      zagnieżdżoną strukturę dokumentu html.
    </p>
    <ul>
      <li>Stwórz wyrażenie regularne, które wyodrębnia wyniki poszczególnych znalezionych w wyszukiwarce pozycji i
        wyodrębni z niego hyperlink z adresem znalezionej strony</li>
      <li>Zastosuj wyrażenie regularne z zadania wprowadzającego nr 5 i 6, które w obrębie znalezionej pozycji
        wyszukiwania wyodrębni wszystkie ciągi pasujące do wzorca numeru telefonu. <strong>Wersja trudniejsza</strong>:
        zmodyfikuj tak wyrażenie regularne żeby znaleźć jak najwięcej numerów telefonów pojawiających się w wynikach
        wyszukiwania.</li>
      <li>znalezione dane zapisuj do mapy <code>std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;</code>,
        której kluczem jest hyperłącze, a wartościami wektor zawierający numery telefonów skojarzone z danym łączem.
        Otwórz 1-2 stron w przeglądarce i zweryfikuj skuteczność z jaką udało Ci się wyodrębnić numery telefonów i
        hyperliniki odnoszące się do wyników wyszukiwania. W wersji podstawowej możesz założyć, żę jeśli znajdziesz
        większość (&gt;50%) numerów pasujących do założonego wzorca, to wymagania zadania zostały spełnione.</li>
      <li>dokonaj transformacji numerów telefonów do znormalizowanej postaci usuwając z nich spacje i myślniki oraz
        nawiasy</li>
      <li>stwórz funkcję <code>std::string href_trimmed = href_trim(href_full)</code>, która z hyperlinku wyodrębni
        wyłącznie nazwę domeny np. dla <code>https://www.biblioteka.wroc.pl/filie/filia-nr-7</code> będzie to
        <code>biblioteka.wroc.pl</code>. Użyj tej wartości jako klucza mapy (wtedy telefony różnych filii zostaną
        pogrupowane w obrębie jednego klucza)
      </li>
      <li>używając algorytmu <code>std::unique_copy</code> lub kontenera <code>std::set</code> spraw, żeby dla danego
        wpisu numery telefonów się nie powtarzały (może się zdarzyć, że dany numer pojawia się na kilku stronach
        należących do tej samej domeny)</li>
      <li>zapisz dane do pliku CSV, w którym w pierwszej kolumnie znajduje się nazwa domeny, a w kolejnych znalezione
        numery telefonów (może się zdarzyć, że w każdym wierszu będzie inna liczba kolumn)</li>
    </ul>
    <hr>
    <p>Autorzy: <em>Piotr Kaczmarek</em></p>
  </main>


</body>

</html>