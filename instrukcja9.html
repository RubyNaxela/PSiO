<!DOCTYPE html>
<!-- saved from url=(0099)http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Lab 09 - alokacja pamieci, polimorfizm, tekstury</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ff0000;
      font-weight: bold;
    }

    /* Alert */
    code span.an {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #7d9029;
    }

    /* Attribute */
    code span.bn {
      color: #40a070;
    }

    /* BaseN */
    code span.bu {}

    /* BuiltIn */
    code span.cf {
      color: #007020;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4070a0;
    }

    /* Char */
    code span.cn {
      color: #880000;
    }

    /* Constant */
    code span.co {
      color: #60a0b0;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #ba2121;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #902000;
    }

    /* DataType */
    code span.dv {
      color: #40a070;
    }

    /* DecVal */
    code span.er {
      color: #ff0000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #40a070;
    }

    /* Float */
    code span.fu {
      color: #06287e;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #007020;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #666666;
    }

    /* Operator */
    code span.ot {
      color: #007020;
    }

    /* Other */
    code span.pp {
      color: #bc7a00;
    }

    /* Preprocessor */
    code span.sc {
      color: #4070a0;
    }

    /* SpecialChar */
    code span.ss {
      color: #bb6688;
    }

    /* SpecialString */
    code span.st {
      color: #4070a0;
    }

    /* String */
    code span.va {
      color: #19177c;
    }

    /* Variable */
    code span.vs {
      color: #4070a0;
    }

    /* VerbatimString */
    code span.wa {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */
  </style>
  <link rel="stylesheet" href="css/github-markdown.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/rubynaxela-darkmode.css">
  <script type="text/javascript" src="js/rubynaxela-navbar.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="icon" type="image/x-icon" href="http://jug.put.poznan.pl/lab-psio/_static/favicon.ico">
</head>

<body>
  <main class="markdown-body">
    <header id="title-block-header">
      <h1 class="title">Lab 09 - alokacja pamieci, polimorfizm, tekstury</h1>
    </header>
    <h1 id="lab-09---alokacja-pamici-polimorfizm-tekstury-w-sfml">Lab 09 - Alokacja pamici, polimorfizm, tekstury w
      SFML</h1>
    <h2 id="c17-standard">C++17 standard</h2>
    <p>Wykorzystywane na tych i nastpnych zajciach elementy jzyka C++ zostay wprowadzone do standardu jako
      <em>C++17</em>. Domylnie <em>QT Creator</em> generuje projekt zgodny ze stndardem <em>C++11</em>, co oznacza, 偶e
      niezbdna jest zmiana ustawie projektu. Otw贸rz plik <em>*.pro</em> i zmie linijk:
    </p>
    <pre><code>CONFIG += console c++11</code></pre>
    <p>na</p>
    <pre><code>CONFIG += console c++17</code></pre>
    <p>Pamitaj o wywoaniu polecenie <em>Run qmake</em> na pliku <em>*.pro</em>.</p>
    <h2 id="wska藕niki">Wska藕niki</h2>
    <p>Zmienne, kt贸re tworzylimy do tej pory w programach poprzez prost deklaracj zmiennej miay sw贸j <em>czas
        偶ycia</em> ograniczony do jednego zakresu (<em>scope</em>) - fragmentu kodu, najczciej wydzielonego klamrami,
      np. ciaa funkcji, czy wntrza ptli. Zmienne te byy tworzone w sekcji pamici operacyjnej zwanej
      <em>stosem</em>. Zmienne i obiekty takie s automatycznie usuwane w momencie wyjcia poza <em>scope</em>, w kt贸rym
      zostay zaalokowane, np. opuszczenia funkcji. W wikszoci przypadk贸w jest to dziaanie po偶dane i zwalnia
      programist z koniecznoci rcznego zarzdzania pamici.
    </p>
    <p>Istniej jednak przypadki, w kt贸rych wskazane jest oddzielenie czasu 偶ycia obiektu od zakresu w kt贸rym zosta on
      utworzony. W tym celu u偶ywamy alokacji na <em>stercie</em>.</p>
    <p>W celu alokacji zmiennych na stercie klasycznie u偶ywano operatora <code>new</code>. Tak utworzon zmienn
      nale偶ao nastpnie usun za pomoc operatora <code>delete</code>. Jako 偶e o operacji dealokacji atwo zapomnie,
      wiele program贸w do dzi przejawia problem nazywany <strong>wyciekiem pamici</strong>.</p>
    <hr>
    <h4 id="-zadanie-"> Zadanie </h4>
    <p>Wykonaj poni偶szy kod obserwujc u偶ycie pamici w <em>Mened偶erze zada</em> (Ctrl + Alt + Delete):</p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> number_of_elements = <span class="dv">100000000</span>;</span>
<span id="cb3-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; number_of_elements; i++) {</span>
<span id="cb3-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> *number = <span class="kw">new</span> <span class="dt">int</span>;</span>
<span id="cb3-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb3-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"Utworzono "</span> &lt;&lt; number_of_elements &lt;&lt; <span class="st">" wskaznikow na wartosc typu int. Nacisnij jakis klawisz aby kontynuowac."</span> &lt;&lt; <span class="bu">std::</span>endl; </span>
<span id="cb3-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>getchar();</span></code></pre>
    </div>
    <hr>
    <p>W celu unikania wyciek贸w pamici, w C++11 wprowadzono nowe typy tzw. inteligentnych wska藕nik贸w (ang. <em>smart
        pointer</em>), w tym <code>std::unique_ptr</code> oraz <code>std::shared_ptr</code>. W tej instrukcji pominiemy
      <code>std::shared_ptr</code>, poniewa偶 su偶y on do przechowywania obiekt贸w, kt贸re maj wielu wacicieli (na
      przykad znajduj si jednoczenie w wicej ni偶 jednym wektorze). <code>std::unique_ptr</code> nie mo偶e by
      kopiowany - obiekt na kt贸ry wskazuje ma tylko jednego waciciela. W celu wykorzystania inteligentnych wska藕nik贸w
      zaimportowa <code>#include &lt;memory&gt;</code>.
    </p>
    <p><code>std::unique_ptr</code> to klasa, kt贸ra w uproszczeniu, przejmuje odpowiedzialno nad <em>czasem 偶ycia</em>
      wska藕nika. W konstruktorze wykonuje alokacj obiektu przy pomocy <code>new</code>, a w destruktorze niszczy go za
      pomoc <code>delete</code>. Zastpujc wykorzystywanie zwykych wska藕nik贸w w stylu jzyka C u偶yciem
      <code>std::unique_ptr</code> mo偶na atwo zapobiec wyciekom pamici. Zmienna typu <code>std::unique_ptr</code>
      automatycznie wywoa <code>delete</code> na przechowywanym wska藕niku kiedy wyjdzie poza zakresu, w kt贸rym zostaa
      zadeklarowana.
    </p>
    <hr>
    <h4 id="-zadanie--1"> Zadanie </h4>
    <p>Zmie poprzedni kod tak, aby zamiast operatora <code>new</code> wykorzystywa typ <code>std::unique_ptr</code>.
      Do stworzenia <code>std::unique_ptr</code> wykorzystaj funkcj <a
        href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique"><code>std::make_unique</code></a>.
      Obserwuj u偶ycie pamici.</p>
    <p><strong>Wskaz贸wka:</strong> jako, 偶e do funkcji <code>std::make_unique</code> przekazujemy typ zmiennej, kt贸r
      chcemy utworzy na stercie mo偶emy <strong>opcjonalnie</strong> u偶y sowa kluczowego <code>auto</code> w celu
      ominicia deklarowania obiektu o dugiej nazwie typu: <code>std::unique_ptr&lt;int&gt;</code>. Nie spowoduje to
      utraty czytelnoci kodu.</p>
    <hr>
    <p>Po przeczytaniu powy偶szego opisu i wykonaniu zadania mo偶na odnie wra偶enie, 偶e alokacja na stosie oraz alokacja
      na stercie z u偶yciem <code>std::unique_ptr</code> s funkcjonalnie identyczne. W obu przypadkach obiekt niszczony
      jest po wyjciu z zakresu w kt贸rym zosta zadeklarowany. Po co wic u偶ywa <code>std::unique_ptr</code>?</p>
    <p>W C++11, obok typu <code>std::unique_ptr</code> wprowadzono r贸wnie偶 <em>move semantics</em> - mo偶liwo
      "przeniesienia" wasnoci obiektu do innego zakresu (<em>scope</em>) lub kontenera. O ile w przypadku obiekt贸w
      zadeklarowanych na stosie owo przeniesienie w wielu przypadkach spowoduje konieczno wykonania kopii przynajmniej
      czci p贸l przenoszonego obiektu, to w przypadku <code>std::unique_ptr</code> przeniesienie nie spowoduje
      kopiowania obiektu na stercie.</p>
    <hr>
    <h4 id="-zadanie--2"> Zadanie </h4>
    <p>Spr贸buj skompilowa poni偶szy kod:</p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>unique_ptr&lt;<span class="dt">int</span>&gt;&gt; some_pointers;</span>
<span id="cb4-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> number_of_elements = <span class="dv">100000000</span>;</span>
<span id="cb4-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; number_of_elements; i++) {</span>
<span id="cb4-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> number = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;();</span>
<span id="cb4-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-5" aria-hidden="true" tabindex="-1"></a>    some_pointers.emplace_back(number);</span>
<span id="cb4-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"Umieszczono "</span> &lt;&lt; number_of_elements &lt;&lt; <span class="st">" elementow w std::vector&lt;std::unique_ptr&lt;int&gt;&gt;. Nacisnij jakis klawisz aby kontynuowac."</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb4-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>getchar();</span></code></pre>
    </div>
    <p>Zastan贸w si dlaczego tak napisany program nie dziaa.</p>
    <p>Pamitajc, 偶e obiekt na kt贸ry wskazuje <code>std::unique_ptr</code> mo偶e mie tylko jednego waciciela, przeka偶
      "prawo wasnoci" wektorowi wywoujc na zmiennej <code>number</code> funkcj <a
        href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>.</p>
    <hr>
    <h2 id="polimorfizm">Polimorfizm</h2>
    <p>U偶ycie wska藕nik贸w na obiekty ze sterty zamiast obiekt贸w na stosie pozwala na atwe zinterpretowanie wska藕nika na
      obiekt klasy pochodnej jako wska藕nika na obiekt klasy bazowej.</p>
    <hr>
    <h4 id="-zadanie--3"> Zadanie </h4>
    <p>Wykorzystujc przykadowe klasy z poprzedniej instrukcji spr贸buj skompilowa poni偶szy kod. Pokazuje on w jaki
      spos贸b mo偶liwe jest przechowywanie elementu klasy pochodnej (<code>Car</code>) we wska藕niku na klas bazow
      (<code>Vehicle</code>).</p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>unique_ptr&lt;Vehicle&gt; skoda_superb_as_vehicle = <span class="bu">std::</span>make_unique&lt;Car&gt;(</span>
<span id="cb5-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Skoda Superb"</span>, <span class="st">"Gasoline"</span>, <span class="dv">200</span>, <span class="kw">true</span>);</span>
<span id="cb5-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"Name: "</span> &lt;&lt; skoda_superb_as_vehicle-&gt;name() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb5-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"Has ABS: "</span> &lt;&lt; skoda_superb_as_vehicle-&gt;has_abs() &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre>
    </div>
    <p>Wiedzc, 偶e traktujemy nasz samoch贸d jako obiekt klasy <code>Vehicle</code> oraz analizujc metody kt贸re s w tej
      klasie zaimplementowane zastan贸w si dlaczego tak napisany program nie dziaa. Usu linijk powodujc bd
      kompilacji.</p>
    <p>Zwr贸 uwag, na r贸偶nic w odwoywaniu si do p贸l obiektu (<code>-&gt;</code> zamiast <code>.</code>). Z czego ona
      wynika?</p>
    <hr>
    <p>Aby klasa bazowa bya polimorficzna musi posiada przynajmniej jedn metod wirtualn (przydomek
      <code>virtual</code>). Metody wirtualne pozwalaj na ich przeci偶anie w klasie pochodnej w taki spos贸b, 偶e gdy
      wywoamy je poprzez wska藕nik do klasy bazowej zostanie wywoana waciwa implementacja z klasy pochodnej. Gdyby
      funkcja nie miaa przydomka <code>virtual</code> to jej wywoanie poprzez wska藕nik do klasy bazowej wywoaoby
      implementacj z klasy bazowej, nie zwa偶ajc na to, 偶e w klasie pochodnej znajduje si przeci偶ona wersja funkcji.
    </p>
    <p>Niezwykle istotne jest aby <strong>ka偶da bazowa klasa polimorficzna</strong> zawieraa deklaracj
      <strong>wirtualnego destruktora</strong>. Jeli taka deklaracja nie znajdzie si w klasie bazowej to usuwanie
      obiektu klasy pochodnej poprzez wska藕nik do klasy bazowej jest <strong>niezdefiniowanym zachowaniem</strong> i
      mo偶e prowadzi do wycieku pamici, gdy偶 wywoany zostanie <strong>tylko</strong> destruktor klasy bazowej.
      Najprostsza deklaracja wirtualnego destruktora wyglda nastpujco:
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">virtual</span> ~ClassName() = <span class="cf">default</span>;</span></code></pre>
    </div>
    <hr>
    <h4 id="-zadanie--4"> Zadanie </h4>
    <p>Do klasy <code>Vehicle</code> dodaj wirtualny destruktor (jako <code>public</code>).</p>
    <hr>
    <p>Rozwizana zostaa kwestia poprawnego wywoywania destruktora. Jednak nadal nie jest mo偶liwe wywoanie metody
      <code>has_abs</code> dla obiektu <code>skoda_superb_as_vehicle</code>, a przecie偶 obiekt ten zosta utworzony z
      wykorzystaniem konstuktora klasy <code>Car</code>.
    </p>
    <p>W celu ponownego zinterpretowania wska藕nika do klasy bazowej jako wska藕nika lub referencji do klasy pochodnej
      nale偶y u偶y wyuskania wska藕nika ("wycignicia" obiektu na kt贸ry wska藕nik wskazuje) oraz specjalnej funkcji
      <code>dynamic_cast</code>. Poni偶szy przykad pozwala wywoa metod <code>has_abs</code>.
    </p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb7-1" aria-hidden="true" tabindex="-1"></a>Car *skoda_superb_as_as_car = <span class="kw">dynamic_cast</span>&lt;Car *&gt;(skoda_superb_as_vehicle.get());</span>
<span id="cb7-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"Has ABS: "</span> &lt;&lt; skoda_superb_as_as_car-&gt;has_abs() &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre>
    </div>
    <h4 id="-zadanie--5"> Zadanie </h4>
    <p>Dodaj definicj klasy <code>Bike</code> z poprzednich zaj, przeanalizuj oraz wykonaj nastpujcy kod:</p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>unique_ptr&lt;Vehicle&gt;&gt; vehicles;</span>
<span id="cb8-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-2" aria-hidden="true" tabindex="-1"></a>vehicles.emplace_back(<span class="bu">std::</span>make_unique&lt;Car&gt;(<span class="st">"Skoda Superb"</span>, <span class="st">"Gasoline"</span>, <span class="dv">200</span>, <span class="kw">true</span>));</span>
<span id="cb8-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-3" aria-hidden="true" tabindex="-1"></a>vehicles.emplace_back(<span class="bu">std::</span>make_unique&lt;Bike&gt;());</span>
<span id="cb8-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; vehicles.size(); i++) {</span>
<span id="cb8-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-6" aria-hidden="true" tabindex="-1"></a>    Car &amp;some_car = <span class="kw">dynamic_cast</span>&lt;Car &amp;&gt;(*vehicles[i]);</span>
<span id="cb8-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb8-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>Dlaczego zwracany jest wyjtek?</p>
    <p>Mo偶emy rozwiza ten problem przechwytujc wyjtek klauzul <code>try...catch</code> lub rzutowa wska藕nik i
      sprawdza czy warto po rzutowaniu jest niezerowa:</p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; vehicles.size(); i++) {</span>
<span id="cb9-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-2" aria-hidden="true" tabindex="-1"></a>    Car *some_car = <span class="kw">dynamic_cast</span>&lt;Car *&gt;(vehicles[i].get());</span>
<span id="cb9-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (some_car != <span class="kw">nullptr</span>) { <span class="co">// cast successful</span></span>
<span id="cb9-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">": abs="</span> &lt;&lt; some_car-&gt;has_abs() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb9-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-5" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> { <span class="co">// nope</span></span>
<span id="cb9-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout &lt;&lt; i &lt;&lt; <span class="st">": not a Car"</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb9-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb9-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p><strong>Uwaga:</strong> zauwa偶, 偶e w tym przypadku, z uwagi na bezporednie przekazanie wyniku dziaania funkcji
      <code>std::make_unique</code> do metody <code>emplace_back</code> (bez u偶ycia zmiennej do kt贸rej przypisujemy
      warto zwracan przez <code>std::make_unique</code>), nie byo koniecznoci u偶ywania <code>std::move</code>.
    </p>
    <hr>
    <h2 id="polimorfizm-a-sfml">Polimorfizm a SFML</h2>
    <p>Wszystkie "rysowalne" klasy z biblioteki SFML dziedzicz po klasie polimorficznej <code>sf::Drawable</code>.
      Oznacza to, 偶e mo偶emy przechowywa wszystkie obiekty sceny w jednym kontenerze jako
      <code>std::unique_ptr&lt;sf::Drawable&gt;</code>. Oznacza to, 偶e np. w naszej grze, nie ma koniecznoci posiadania
      osobnych kontener贸w dla drzew, krzew贸w, kwiat贸w czy innych obiekt贸w. Wszystkie podobne do siebie elementy
      zgrupujemy mo偶emy zgrupwa razem co upraszcza kod i zmniejsza liczb powt贸rze.
    </p>
    <hr>
    <h4 id="-zadanie--6"> Zadanie </h4>
    <p>Korzystajc z teorii zamieszczonej powy偶ej utw贸rz w projekcie SFML wsp贸lny wektor kilku obiekt贸w o r贸偶nych
      ksztatach i kolorach.</p>
    <p>W ptli g贸wnej programu wywouj metod draw na wyuskanych ze wska藕nika obiektach <code>sf::Drawable</code>.</p>
    <p>Wykorzystaj kod z instrukcji [<a
        href="http://jug.put.poznan.pl/lab-psio/Lab%2007%20-%20Wprowadzenie%20do%20SFML.html#tworzenie-projektu-wykorzystuj%C4%85cego-sfml">Lab
        07 - Wprowadzenie do SFML</a>] i umie utworzone koo, prostokt i tr贸jkt w wektorze:</p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>unique_ptr&lt;sf::Drawable&gt;&gt; shapes;</span></code></pre>
    </div>
    <p>Zamiast osobno wywoywa rysowanie dla poszczeg贸lnych figur wykorzystaj:</p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(<span class="at">const</span> <span class="kw">auto</span> &amp;s : shapes) {</span>
<span id="cb11-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb11-2" aria-hidden="true" tabindex="-1"></a>    window.draw(*s);</span>
<span id="cb11-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb11-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>Nastpnie utw贸rz funkcj, w kt贸rej zamiecisz cay kod do generacji figur. Funkcja powinna zwraca utworzony
      kontener.</p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> create_shapes(<span class="bu">std::</span>vector&lt;<span class="bu">std::</span>unique_ptr&lt;sf::Drawable&gt;&gt;  &amp;shapes)</span></code></pre>
    </div>
    <hr>
    <h2 id="teksturyspritey-w-sfml">Tekstury/sprite'y w SFML</h2>
    <p>Teksturowanie to nanoszenie na ksztaty geometryczne paskiego, dwuwymiarowego obrazu, tak aby nada
      odzworowywanemu przedmiotowi wygld bli偶szy prawdziwemu.</p>
    <p>W przypadku grafiki dwuwymiarowej u偶ywa si pojcia sprite'u - paskiej bitmapy, kt贸ra w caoci lub fragmencie
      renderowana jest w okrelonym miejscu na ekranie.</p>
    <h3 id="skd-wzi-tekstury">Skd wzi tekstury?</h3>
    <p>Istnieje wiele witryn internetowych z darmowymi zasobami multimedialnymi, takimi jak tekstury, sprite'y czy
      d藕wiki - w szczeg贸lnoci do zastosowa niekomercyjnych. Bazy maj zazwyczaj dobrze zorganizowany katalog, co
      uatwia znalezienie odpowiedniego zasobu.</p>
    <p><strong>Pamitaj</strong> - jeli korzystasz z grafiki pobranej z Internetu, sprawd藕 na jakiej licencji zostay
      udostpnione zasoby. Czsto autorzy oczekuj jedynie tzw. <em>uznania autorstwa</em> (ang. <em>attribution</em>) -
      wzmianki w informacjach o programie, skd pochodz zasoby i kto jest ich autorem.</p>
    <p>Poni偶ej umieszczono odnoniki do kilku tekstur, od kt贸rych mo偶esz rozpocz: <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/grass.png">grass</a>, <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/wall.png">wall</a>, <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/guy.png">guy</a>.</p>
    <h3 id="u偶ycie-tekstur">U偶ycie tekstur</h3>
    <p>W SFML <em>tekstur</em> nazywamy obraz, kt贸ry przechowywany jest w pamici, natomiast <em>sprite</em> to
      ksztat, kt贸ry bdzie wywietlony na ekranie, i kt贸ry mo偶e by powizany z dan tekstur.</p>
    <p>Dodatkowy opis wykorzystania sprite'贸w mo偶na znale藕 <a
        href="https://www.sfml-dev.org/tutorials/2.5/graphics-sprite.php">tutaj</a></p>
    <p>Najprostsze u偶ycie tekstury polega na wczytaniu bitmapy z pliku do obiektu <code>sf::Texture</code>, a nastpnie
      utworzeniu obiektu <code>sf::Sprite</code> i powizaniu z zaadowan tekstur.</p>
    <div class="sourceCode" id="cb13">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-1" aria-hidden="true" tabindex="-1"></a>sf::Texture texture;</span>
<span id="cb13-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (!texture.loadFromFile(<span class="st">"grass.png"</span>)) {</span>
<span id="cb13-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cerr &lt;&lt; <span class="st">"Could not load texture"</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb13-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb13-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-7" aria-hidden="true" tabindex="-1"></a>sf::Sprite sprite;</span>
<span id="cb13-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb13-8" aria-hidden="true" tabindex="-1"></a>sprite.setTexture(texture);</span></code></pre>
    </div>
    <p>Klasa <code>sf::Sprite</code> dziedziczy z klas <code>sf::Drawable</code> oraz <code>sf::Transformable</code>,
      zatem ma dostpne metody, kt贸re pozwalaj na transformacje geometryczne (przesuwanie, obracanie, skalowanie).
      Ponadto, dziki polimorfizmowi sprite'y mog by przechowywane w jednym kontenerze wraz z ksztatami takimi jak
      <code>sf::RectangleShape</code>.
    </p>
    <hr>
    <h4 id="-zadanie--7"> Zadanie </h4>
    <p>Wczytaj do programu dostarczone tekstury.</p>
    <p>Utw贸rz po jednym sprite dla ka偶dej z nich, wywietl je na ekranie w r贸偶nych miejscach i w r贸偶nej skali
      (<code>sf::Transformable::setScale</code>).</p>
    <hr>
    <p>Jeli chcemy, aby dany sprite wywietla jedynie fragment powizanej z nim tekstury, mo偶emy u偶y na nim metody
      <code>setTextureRect(sf::Rect)</code>, kt贸ra pozwoli nam wskaza wybrany obszar. Wykorzystaj t metod do
      wywietlenia tylko twarzy wczytanej postaci.
    </p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb14-1" aria-hidden="true" tabindex="-1"></a>sf::Texture texture_guy;</span>
<span id="cb14-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(!texture_guy.loadFromFile(<span class="st">"guy.png"</span>)) { <span class="cf">return</span> <span class="dv">1</span>; }</span>
<span id="cb14-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb14-4" aria-hidden="true" tabindex="-1"></a>sf::Sprite guy;</span>
<span id="cb14-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb14-5" aria-hidden="true" tabindex="-1"></a>guy.setTexture(texture_guy);</span>
<span id="cb14-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb14-6" aria-hidden="true" tabindex="-1"></a>guy.setTextureRect(sf::IntRect(<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">15</span>)); <span class="co">//left, top, width, height</span></span></code></pre>
    </div>
    <p><img src="img/head.png" alt="head"></p>
    <p>Jeli wybierzemy do wywietlenia obszar wikszy ni偶 rozmiar tekstury, a dodatkowo przestawimy tekstur w tryb
      <em>Repeated</em> (metoda <code>sf::Texture::setRepeated(bool)</code>, uzyskamy <em>kafelkowanie</em> (ang.
      <em>tiling</em>), czyli tekstura bdzie powielana ssiadujco tak aby wypeni cay obszar. Przeanalizuj:
    </p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-1" aria-hidden="true" tabindex="-1"></a>sf::Texture texture_wall;</span>
<span id="cb15-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(!texture_wall.loadFromFile(<span class="st">"wall.png"</span>)) { <span class="cf">return</span> <span class="dv">1</span>; }</span>
<span id="cb15-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-3" aria-hidden="true" tabindex="-1"></a>texture_wall.setRepeated(<span class="kw">true</span>);</span>
<span id="cb15-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-5" aria-hidden="true" tabindex="-1"></a>sf::Sprite wall;</span>
<span id="cb15-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-6" aria-hidden="true" tabindex="-1"></a>wall.setTexture(texture_wall);</span>
<span id="cb15-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-7" aria-hidden="true" tabindex="-1"></a>wall.setScale(<span class="fl">0.3</span>, <span class="fl">0.3</span>);</span>
<span id="cb15-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb15-8" aria-hidden="true" tabindex="-1"></a>wall.setTextureRect(sf::IntRect(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">500</span>, <span class="dv">500</span>));</span></code></pre>
    </div>
    <p><img src="img/wall_repeated.png" alt="wall_repeated"></p>
    <hr>
    <h4 id="-zadanie--8"> Zadanie </h4>
    <p>Wykorzystaj kafelkowanie i tekstur <em>grass</em>, aby utworzy to w programie. Ustal odpowiedni
      <code>TextureRect</code> dla sprite'a reprezentujcego to tak, aby obejmowa cay rozmiar okna.
    </p>
    <hr>
    <p><strong>Wa偶ne:</strong> dowizanie tekstury do sprite'a nie powoduje skopiowania jej zawartoci - jeli obiekt
      <code>sf::Texture</code> zostanie usunity i spr贸bujemy wywietli sprite, z kt贸rym by powizany, w miejsce
      tekstury pojawi si biae wypenienie.
    </p>
    <p>Warto te偶 ograniczy liczb tekstur i operacji na nich do minimum - na przykad u偶ywa tej samej tekstury dla
      wielu obiekt贸w. W przypadku prostych gier, kt贸re nie maj wiele zasob贸w, najlepiej wczyta wszystkie niezbdne
      tekstury na pocztku uruchamiania programu i utrzymywa w pamici a偶 do jego zakoczenia.</p>
    <hr>
    <h2 id="animacje">Animacje</h2>
    <p>Animacje w grach zbudowanych na sprite'ach opieraj si na zestawie nastpujcych po sobie klatek animacji,
      przeczanych w odpowiednich momentach.</p>
    <p>Czsto kolejne klatki animacji umieszczone s w jednej teksturze, a wyb贸r danej klatki odbywa si poprzez
      wskazanie odpowiedniego fragmentu tekstury (przypomnienie: metoda <code>setTextureRect(sf::Rect)</code>. Dziki
      temu caa animacja mo偶e by przechowywana w pamici ukadu graficznego, a przejcie do kolejnej klatki animacji
      nie jest kosztowne obliczeniowo.</p>
    <hr>
    <h4 id="-zadanie--9"> Zadanie </h4>
    <p>Napisz klas <code>AnimatedSprite</code> dziedziczc po <code>sf::Sprite</code>.</p>
    <p>Klasa powinna mie interfejs, kt贸ry pozwoli na wskazanie fragment贸w tekstury bdcych kolejnymi klatkami
      animacji:</p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> animation_fps = <span class="dv">7</span>;</span>
<span id="cb16-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-2" aria-hidden="true" tabindex="-1"></a>AnimatedSprite hero(animation_fps);</span>
<span id="cb16-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">/* add texture, set parameters, etc. */</span></span>
<span id="cb16-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-6" aria-hidden="true" tabindex="-1"></a>hero.add_animation_frame(sf::IntRect(<span class="dv">200</span>, <span class="dv">0</span>, <span class="dv">37</span>, <span class="dv">37</span>)); <span class="co">// 1 frame of animation</span></span>
<span id="cb16-7"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-7" aria-hidden="true" tabindex="-1"></a>hero.add_animation_frame(sf::IntRect(<span class="dv">250</span>, <span class="dv">0</span>, <span class="dv">37</span>, <span class="dv">37</span>)); <span class="co">// 2 frame</span></span>
<span id="cb16-8"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-8" aria-hidden="true" tabindex="-1"></a>hero.add_animation_frame(sf::IntRect(<span class="dv">300</span>, <span class="dv">0</span>, <span class="dv">37</span>, <span class="dv">37</span>)); <span class="co">// 3 frame</span></span>
<span id="cb16-9"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2009%20-%20alokacja%20pamieci,%20polimorfizm,%20tekstury.html#cb16-9" aria-hidden="true" tabindex="-1"></a>hero.add_animation_frame(sf::IntRect(<span class="dv">350</span>, <span class="dv">0</span>, <span class="dv">37</span>, <span class="dv">37</span>)); <span class="co">// 4 frame</span></span></code></pre>
    </div>
    <p>Klasa powinna mie metod <code>step</code>, dziki kt贸rej bdzie mo偶liwe informowanie obiektu o czasie jaki
      upyn. Klasa na podstawie tego czasu oraz wewntrznego parametru opisujcego liczb klatek na sekund, powinna
      decydowa, czy ma nastpi przeczenie na kolejn klatk animacji.</p>
    <p>Stw贸rz na scenie obiekt klasy <code>AnimatedSprite</code>, wykorzystaj tekstur postaci z <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/sprites.zip">zaczonego zestawu tekstur</a>.</p>
    <hr>
    <h2 id="grawitacja">Grawitacja</h2>
    <p>Grawitacja to stae przyspieszenie dziaajce w pionowym kierunku. Tak samo, jak w ka偶dym <em>kwancie czasu</em>
      bie偶ca <em>prdko</em> wpywa na poo偶enie obiektu, tak bie偶ce <em>przyspieszenie</em> wpywa na
      <em>prdko</em>.
    </p>
    <hr>
    <h4 id="-zadanie--10"> Zadanie </h4>
    <p>Dodaj do klasy <code>AnimatedSprite</code> informacj o prdkoci obiektu, analogicznie do klasy
      <code>CustomRectangleShape</code>. Dodaj kolejn pochodn poo偶enia - przyspieszenie i dodaj odpowiednie
      oblicznenia w metodzie <code>step</code>. Ustaw pionow skadow przyspieszenia tak, aby obiekt "spada". Dodaj
      odpowiednie parametry i warunki opisujce prdko graniczn.
    </p>
    <hr>
    <h2 id="zadania-kocowe-">Zadania kocowe </h2>
    <h4 id="labirynt">Labirynt</h4>
    <p>Wykorzystujc dostarczone tekstury zbuduj gr <em>Labirynt</em></p>
    <ul>
      <li>ustaw to gry</li>
      <li>dodaj do sceny kilka obiekt贸w - cian z odpowiedni tekstur</li>
      <li>dodaj posta, kt贸r bdziesz m贸g porusza klawiszami kursora</li>
      <li>dodaj detekcj kolizji tak, aby niemo偶liwe byo przechodzenie przez ciany</li>
    </ul>
    <p>Ostateczny efekt powinien by podobny do tego na <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/labyrinth.mov">filmie</a>.</p>
    <h4 id="platformer">Platformer</h4>
    <p>Bazujc na kodzie su偶cym do wykrywania kolizji w zadaniu z poprzednich zaj, napisz prosty silnik gry
      platformowej:</p>
    <ul>
      <li>dodaj do sceny kilka obiekt贸w - platform z odpowiedni tekstur</li>
      <li>dodaj posta - <code>AnimatedSprite</code>, kt贸r bdziesz m贸g porusza klawiszami kursora w lewo i w prawo,
        ustal dla niej grawitacj</li>
      <li>dodaj kod wykrywajcy kolizje pomidzy postaci a kt贸rkolwiek z platform, tak aby posta moga sta na
        platformach</li>
      <li>dodaj skakanie - jeli posta dotyka podo偶a, nadaj jej prdko pocztkow w g贸r</li>
    </ul>
    <hr>
    <p>Autorzy: <em>Micha Fularz</em>, <em>Tomasz Makowski</em>, <em>Dominik Pieczyski</em>, <em>Jakub
        Tomczyski</em></p>
  </main>


</body>

</html>