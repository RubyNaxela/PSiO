<!DOCTYPE html>
<!-- saved from url=(0060)http://jug.put.poznan.pl/lab-psio/Lab%2010%20-%20OpenGL.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Lab 10 - OpenGL</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }
  </style>
  <link rel="stylesheet" href="css/github-markdown.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/rubynaxela-darkmode.css">
  <script type="text/javascript" src="js/rubynaxela-navbar.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="icon" type="image/x-icon" href="http://jug.put.poznan.pl/lab-psio/_static/favicon.ico">
</head>

<body>
  <main class="markdown-body">
    <header id="title-block-header">
      <h1 class="title">Lab 10 - OpenGL</h1>
    </header>
    <h1 id="lab-10---opengl">Lab 10 - OpenGL</h1>
    <h2 id="opengl-i-glu-w-sfml">OpenGL i GLU w SFML</h2>
    <p>OpenGL jest otwartym, niskopoziomowym API pozwalajcym na generowanie tr贸jwymiarowej grafiki. Poniewa偶 biblioteka
      SFML wykorzystuje wewntrznie OpenGL do rysowania grafiki 2D, mo偶emy j wykorzysta jako bibliotek pomocnicz
      uatwiajc np. utworzenie okna i obsug zdarze (np. obsug urzdze wejcia jak myszka czy klawiatura).</p>
    <p>OpenGL dostarcza m.in. funkcje rysujce pojedyncze wielokty lub serie wielokt贸w oraz ich przeksztacenia. Nieco
      bardziej wysokopoziomowe funkcje s czci biblioteki GLU (GL Utilility Library).</p>
    <p>Poniewa偶 bdziemy wykorzystywa bezporednio funkcje OpenGL oraz GLU, wymagane jest doczenie ich do listy
      bibliotek dla przekazanych w parametrach linkerowi. W przypadku rodowiska Qt Creator, dodajemy do pliku
      <code>.pro</code> poni偶sz lini:
    </p>
    <pre><code>LIBS += -lOpenGL32 -lglu32</code></pre>
    <h2 id="pierwszy-program-opengl--sfml">Pierwszy program OpenGL + SFML</h2>
    <p>Stw贸rz projekt do pracy z SFML oraz OpenGL. Umie w projekcie plik <code>main.cpp</code> z zawartoci pobran z
      odnonika <a href="http://jug.put.poznan.pl/lab-psio/_resources/sfml_opengl.cpp">sfml_opengl.cpp</a>.</p>
    <p>Uruchom program. Na ekranie powinien si pojawi obracajcy si kolorowy szecian.</p>
    <p>Struktura kodu programu jest analogiczna do poprzednich program贸w SFML - nastpuje inicjalizacja rodowiska (w
      tym parametr贸w OpenGL, takich jak np. model owietlenia), a nastpnie, w g贸wnej ptli, rysowane s klatki obrazu.
    </p>
    <p>W tr贸jwymiarowej grafice komputerowej najczciej wykorzystuje si reprezentacj bry w postaci siatki wielokt贸w
      - ka偶dy obiekt zbudowany jest z paskich wielokt贸w (najczciej tr贸jkt贸w lub czworokt贸w), kt贸re maj wsp贸lne
      wierzchoki i krawdzie. Pozwala to w atwy spos贸b stworzy proste bryy, a tak偶e przybli偶y skomplikowane obiekty
      dostatecznie gst siatk.</p>
    <p>Zaczona funkcja rysujca szecian rysuje ka偶d z jego cian jako kwadrat, w r贸偶nych kolorach.</p>
    <p>Aby zapewni stae proporcje wywietlanego obrazu i zakres widocznoci w pionie, po ka偶dym <em>evencie</em> typu
      <code>sf::Event::Resized</code> (zmiana rozmiaru okna), wywoywana jest funkcja <code>set_viewport</code>. Funkcja
      ta wykorzystujc informacje o nowym rozmiarze okna ustawia odpowiednio zakres widzianej sceny
      (<code>glFrustrum</code>) oraz ustawia pozycj kamery (<code>gluLookAt</code>).
    </p>
    <hr>
    <h4 id="-zadanie-"> Zadanie </h4>
    <p>Przeanalizuj dziaanie przykadowego kodu. Sprawd藕 dziaanie funkcji <code>glTranslated</code>,
      <code>glRotated</code> i <code>glColor3d</code> poprzez modyfikacj ich parametr贸w. Spr贸buj wywnioskowa jak
      uo偶one s osie ukadu wsp贸rzdnych sceny.
    </p>
    <hr>
    <h3 id="transformacje-geometryczne-w-opengl">Transformacje geometryczne w OpenGL</h3>
    <p>Aplikacje OpenGL wykorzystuj ukad wsp贸rzdnych do lokalizacji obiekt贸w na scenie. Aby unikn koniecznoci
      rcznego przeliczania poo偶e wierzchok贸w obiekt贸w na scenie, ukad ten mo偶na transformowa (m.in. przesuwa i
      obraca):</p>
    <ul>
      <li><code>glTranslated(double x, double y, double z)</code> - przesuwa ukad wsp贸rzdnych o odlegoci podane
        jako argumenty,</li>
      <li><code>glRotated(double angle, double x, double y, double z)</code> - obraca ukad wsp贸rzdnych o kt
        <code>angle</code> (w stopniach) wok贸 osi zdefiniowanej przez parametry <code>x</code>, <code>y</code>,
        <code>z</code>.
      </li>
    </ul>
    <p>Nale偶y pamita, 偶e kolejno ma istotne znaczenie. Rozwa偶 poni偶sze przykady:</p>
    <ul>
      <li>w pierwszej kolejnoci wykonano operacj translacji (przesunicia), a nastpnie rotacji (obrotu):</li>
    </ul>
    <p><img class="black-and-white" src="img/translation_rotation.png" alt="Translation then rotation"></p>
    <ul>
      <li>w drugim przykadzie zrealizowano te same transformacje, jednak w odwrotnej kolejnoci - najpierw rotacj
        (obr贸t), a nastpnie translacj (przesunicie).</li>
    </ul>
    <p><img class="black-and-white" src="img/rotation_translation.png" alt="Rotation then translation"></p>
    <p>W efekcie wykonanie tych samych operacji (ale w innej kolejnoci) daje inny efekt - por贸wnaj poo偶enie oraz
      orientacj samolotu w obu przypadkach.</p>
    <p>W celu uatwienia powrotu do punktu wyjcia (np. po wykonaniu szeregu przeksztace) udostpniono nastpujce
      funkcje:</p>
    <ul>
      <li><code>glPushMatrix()</code> - zapisuje aktualny stan (poo偶enie oraz orientacj) ukadu wsp贸rzdnych,</li>
      <li><code>glPopMatrix()</code> - pobiera ostatnio zapisany stan (poo偶enie oraz orientacj) ukadu wsp贸rzdnych.
        Nale偶y pamita, 偶e dla ka偶dego wywoania <code>glPushMatrix()</code> obowizkowo nale偶y wywoa jedno
        <code>glPopMatrix()</code>. Mo偶na traktowa je jak klamry opasajce fragment kodu, kt贸rego tycz si
        przeksztacenia.
      </li>
    </ul>
    <p>Rozwa偶my przykad przedstawiony na rysunku poni偶ej:</p>
    <p><img class="black-and-white" src="img/push_pop.png" alt="Rotation then translation"></p>
    <p>Planujemy narysowa dwa samoloty - w punkcie <em>(4, 4)</em>, a nastpnie <em>(2, 1)</em>. Bez wykorzystania
      funkcji <code>glPushMatrix()</code> / <code>glPopMatrix()</code> (operacje przedstawione nad obrazkiem) niezbdne
      jest wyliczenie jak przesun si z punktu <em>(4, 4)</em> do <em>(2, 1)</em>. W zaprezentowanym przykadzie
      wydaje si to atwe, ale przeksztace mo偶e by wicej i mog by wr贸d nich rotacje komplikujce zadanie. Z
      wykorzystaniem funkcji <code>glPushMatrix()</code> / <code>glPopMatrix()</code> (operacje pod rysunkiem) zadanie
      jest mniej skomplikowane - nie trzeba wykonywa 偶adnych transformacji odwrotnych - wystarczy na pocztku
      zapamita aktualny stan, a p贸藕niej do niego powr贸ci.</p>
    <hr>
    <h4 id="-zadanie--1"> Zadanie </h4>
    <p>Dodaj do sceny dwa dodatkowe szeciany o r贸偶nych wielkociach. Ka偶dy z nich rysuj w innym miejscu sceny i obracaj
      wok贸 innej osi. Wykorzystaj funkcje <code>glPushMatrix()</code> / <code>glPopMatrix()</code>.</p>
    <hr>
    <p>Poza przesuwaniem i obracaniem ukadu mo偶na go r贸wnie偶 skalowa (funkcja <code>glScaled()</code>).</p>
    <hr>
    <h4 id="-zadanie--2"> Zadanie </h4>
    <p>Korzystajc z ptli zdarze dodaj do programu mo偶liwo przesuwania kamery w poziomie klawiszami <em>WSAD</em>
      oraz oddalania/przybli偶ania widoku k贸kiem myszy (event <code>sf::Event::MouseWheelScrolled</code> oraz pole
      <code>event.mouseWheelScroll.delta</code>).
    </p>
    <p><em>Podpowied藕</em>: zamiast przesuwa kamer mo偶esz zmodyfikowa (przesuwa i skalowa) ukad wsp贸rzdnych, w
      kt贸rym rysowane s wszystkie obiekty.</p>
    <hr>
    <h2 id="zadanie-kocowe-">Zadanie kocowe </h2>
    <h4 id="1-planetarium">1. Planetarium</h4>
    <p>Napisz program obrazujcy ruch planet w Ukadzie Sonecznym.</p>
    <p>Napisz klas <code>CelestialBody</code> reprezentujc ciao niebieskie - aby lepiej widzie ruch obrotowy
      planet, mo偶esz reprezentowa je jako szeciany.</p>
    <p>Cechy ciaa niebieskiego:</p>
    <ul>
      <li>rednica</li>
      <li>odlego od soca</li>
      <li>okres ruchu obrotowego</li>
      <li>okres ruchu obiegowego</li>
      <li>kolor powierzchni</li>
    </ul>
    <p>Klasa powinna mie metod <code>step(float time)</code> (analogicznie do program贸w z poprzednich zaj) oraz
      <code>draw()</code> powodujc narysowanie planety.
    </p>
    <p>Zastan贸w si nad kolejnoci transformacji potrzebnych do narysowania planety w odpowiednim miejscu i o
      odpowiednim kcie obrotu (podpowied藕: nie potrzebujesz trygonometrii!).</p>
    <p>Wczytaj zawarto pliku <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/solar_system.txt">solar_system.txt</a> i na jego podstawie
      utw贸rz obiekty na scenie reprezentujce wszystkie planety i soce. <strong>Uwaga:</strong> odlegoci i rednice
      w pliku s zmodyfikowane tak, aby wizualizacja pozostaa czytelna. Prawdziwe wartoci mo偶na znale藕 w pliku <a
        href="http://jug.put.poznan.pl/lab-psio/_resources/solar_system_real.txt">solar_system_real.txt</a></p>
    <hr>
    <p>Autorzy: <em>Tomasz Makowski</em>, <em>Jakub Tomczyski</em></p>
  </main>


</body>

</html>