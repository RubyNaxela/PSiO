<!DOCTYPE html>
<!-- saved from url=(0082)http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Lab 01 - Proste algorytmy, vector</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    span.underline {
      text-decoration: underline;
    }

    div.column {
      display: inline-block;
      vertical-align: top;
      width: 50%;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      display: inline-block;
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {}

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ff0000;
      font-weight: bold;
    }

    /* Alert */
    code span.an {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #7d9029;
    }

    /* Attribute */
    code span.bn {
      color: #40a070;
    }

    /* BaseN */
    code span.bu {}

    /* BuiltIn */
    code span.cf {
      color: #007020;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4070a0;
    }

    /* Char */
    code span.cn {
      color: #880000;
    }

    /* Constant */
    code span.co {
      color: #60a0b0;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #ba2121;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #902000;
    }

    /* DataType */
    code span.dv {
      color: #40a070;
    }

    /* DecVal */
    code span.er {
      color: #ff0000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #40a070;
    }

    /* Float */
    code span.fu {
      color: #06287e;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #007020;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #666666;
    }

    /* Operator */
    code span.ot {
      color: #007020;
    }

    /* Other */
    code span.pp {
      color: #bc7a00;
    }

    /* Preprocessor */
    code span.sc {
      color: #4070a0;
    }

    /* SpecialChar */
    code span.ss {
      color: #bb6688;
    }

    /* SpecialString */
    code span.st {
      color: #4070a0;
    }

    /* String */
    code span.va {
      color: #19177c;
    }

    /* Variable */
    code span.vs {
      color: #4070a0;
    }

    /* VerbatimString */
    code span.wa {
      color: #60a0b0;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */
  </style>
  <link rel="stylesheet" href="css/github-markdown.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/rubynaxela-darkmode.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="icon" type="image/x-icon" href="http://jug.put.poznan.pl/lab-psio/_static/favicon.ico">
</head>

<body>
  <main class="markdown-body">
    <header id="title-block-header">
      <h1 class="title">Lab 01 - Proste algorytmy, vector</h1>
    </header>
    <h1 id="lab-01---vector-algorytmy">Lab 01 - <code>vector</code>, algorytmy</h1>
    <h2 id="wstp---kontener-vector">Wstp - kontener <code>vector</code></h2>
    <p>W C++ kontenerem lub kolekcj nazywamy struktur danych, kt贸ra pozwala na przechowywanie wielu element贸w
      <strong>tego samego typu</strong>.
    </p>
    <p>Najprostszym kontenerem, kt贸ry bdziemy wykorzystywa podczas niekt贸rych z dzisiejszych zada jest
      <code>vector</code>. Kontenery z biblioteki standardowej zdefiniowane s w nag贸wkach o nazwie takiej samej jak
      nazwa kontenera, std aby u偶y <code>vector</code>a musimy zaczy jego nag贸wek:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span></code></pre>
    </div>
    <p>Wewntrznie wektor jest tablic, "opakowan" w klas dostarczajc interfejs uatwiajcy wiele czynnoci takich
      jak zmian jego rozmiaru, dodawanie element贸w, kopiowanie caego wektora czy u偶ycie algorytm贸w.</p>
    <h3 id="tworzenie-wektor贸w">Tworzenie wektor贸w</h3>
    <p>Klasa <code>vector</code> jest <em>szablonem</em> - mo偶e przechowywa dowolny typ zmiennych, obiekt贸w, jednak
      musi on by znany w trakcie kompilacji i podajemy go w momencie tworzenia wektora w nawiasach ostrych:</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v1; <span class="co">// utworzenie pustego wektora v1 przechowujcego elementy typu int</span></span></code></pre>
    </div>
    <p><code>vector</code> mo偶emy utworzy na kilka sposob贸w, poza pustym kontenerem (jak powy偶ej), mo偶emy od razu
      zainicjalizowa go wartociami:</p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; some_zeros(<span class="dv">5</span>); <span class="co">// 5-elementowy wektor o domylnych wartociach (0 dla typ贸w liczbowych)</span></span>
<span id="cb3-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; four_pies(<span class="dv">4</span>, <span class="fl">3.14</span>); <span class="co">// 4-elementowy wektor, wszystkie elementy o wartoci 3.14</span></span></code></pre>
    </div>
    <p>Mo偶liwe jest r贸wnie偶 u偶ycie <strong>listy inicjalizacyjnej</strong>:</p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>string&gt; messages = {<span class="st">"nope"</span>, <span class="st">"cool"</span>, <span class="st">"OK"</span>}; <span class="co">// 3-elementowy wektor z podanymi wartociami</span></span></code></pre>
    </div>
    <p>Wektory mog przechowywa klasy, struktury; elementami wektora mog by te偶 inne kolekcje, np. kolejny wektor,
      pozwalajc na stworzenie wielowymiarowych struktur:</p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;&gt; matrix; <span class="co">// wektor wektor贸w (struktura dwuwymiarowa)</span></span></code></pre>
    </div>
    <h3 id="dostp-do-element贸w-wektora">Dostp do element贸w wektora</h3>
    <p>Poniewa偶 wektor jest wewntrznie tablic, mo偶liwy jest <strong>swobodny dostp</strong> do poszczeg贸lnych
      element贸w, dokadnie tak jak w tablicy (pamitaj, 偶e indeksowanie zaczyna si od 0):</p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; numbers = {<span class="fl">1.0</span>, -<span class="dv">100</span>, <span class="fl">1.4142</span>};</span>
<span id="cb6-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; numbers[<span class="dv">1</span>] &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// wypisze -100</span></span>
<span id="cb6-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb6-3" aria-hidden="true" tabindex="-1"></a>numbers[<span class="dv">2</span>] = <span class="fl">3.14</span>; <span class="co">// zmodyfikuje trzeci element</span></span></code></pre>
    </div>
    <p>Bie偶cy rozmiar wektora mo偶na sprawdzi metod <code>size()</code>. W ten spos贸b mo偶emy np. przejrze kontener
      tak jak tablic:</p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; numbers.size(); i++) {</span>
<span id="cb7-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb7-2" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>cout &lt;&lt; numbers[i] &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb7-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb7-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>W przypadku kontener贸w du偶ym uatwieniem jest mo偶liwo korzystania z ptli skr贸conej typu <em>range-based for
        loop</em>:</p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb8-1" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// wykonuje ptl dla ka偶dego elementu w numbers, w ka偶dym przebiegu</span></span>
<span id="cb8-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="dt">double</span> &amp;n : numbers) { <span class="co">// tworzy zmienn n - referencj do danego elementu</span></span>
<span id="cb8-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; n &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb8-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb8-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>Mo偶liwy jest r贸wnie偶 dostp z wykorzystaniem <strong>iterator贸w</strong> - obiekt贸w zachowujcych si jak
      wska藕niki, ale dedykowanych konkretnemu typowi kontenera. Wicej o iteratorach dowiesz si na kolejnych zajciach.
    </p>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;::iterator it = numbers.begin(); it != numbers.end(); it++) {</span>
<span id="cb9-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; *it &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// it zachowuje si jak wska藕nik, musimy wyuska spod niego warto</span></span>
<span id="cb9-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb9-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <h3 id="modyfikacja-wektora">Modyfikacja wektora</h3>
    <p>Najczciej wykonywane operacje modyfikujce zawarto wektora to:</p>
    <ul>
      <li><code>emplace_back(value)</code> - dodaje warto na kocu wektora, np.
        <code>numbers.emplace_back(777.0);</code>
      </li>
      <li><code>resize(size)</code> - zmienia rozmiar wektora na podan warto</li>
      <li><code>clear()</code> - usuwa wszystkie elementy i zmienia rozmiar wektora na 0</li>
    </ul>
    <p>Chocia偶 wektor mo偶e by dowolnie modyfikowany, ka偶da zmiana jego rozmiaru mo偶e si wiza z koniecznoci
      zaalokowania nowej pamici i przeniesienia wszystkich element贸w. Jeli znasz liczb element贸w w trakcie tworzenia
      kolekcji, warto utworzy od razu wektor o zadanej wielkoci.</p>
    <h3 id="kopiowanie-przekazywanie-do-funkcji">Kopiowanie, przekazywanie do funkcji</h3>
    <p>Wektor, podobnie jak inne kontenery, ma zaimplementowane mechanizmy kopiujce jego zawarto element po elemencie
      w przypadku zapisywania do nowej zmiennej.</p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>};</span>
<span id="cb10-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; b = a; <span class="co">// spowoduje utworzenie nowego wektora (zaalokowanie nowej pamici)</span></span>
<span id="cb10-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb10-3" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// i skopiowanie zawartoci element po elemencie</span></span>
<span id="cb10-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb10-4" aria-hidden="true" tabindex="-1"></a>b[<span class="dv">1</span>] = <span class="dv">100</span>; <span class="co">// modyfikuje tylko wektor b</span></span></code></pre>
    </div>
    <p>Oznacza to, 偶e w przypadku przekazywania wektora jako argumentu do funkcji poprzez warto, zostanie on
      niepotrzebnie skopiowany, a jakiekolwiek zmiany bd odbyway si na kopii, wewntrz funkcji.</p>
    <p>Jeli argument ma podlega modyfikacji nale偶y go przekaza jako referencj (znak <code>&amp;</code> przed nazw
      argumentu), a jeli modyfikacja oryginalnej kolekcji nie jest wymagana, nale偶y przekazywa argument jako
      <code>const reference</code>:
    </p>
    <div class="sourceCode" id="cb11">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_vector(<span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp;param) {</span>
<span id="cb11-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* read-only stuff */</span> </span>
<span id="cb11-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb11-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <h3 id="dokumentacja">Dokumentacja</h3>
    <p>W instrukcji przedstawiono jedynie podstawow funkcjonalno, szeg贸owy opis mo偶na znale藕 w dokumentacji, np:
    </p>
    <p><a href="http://www.cplusplus.com/reference/vector/vector/">http://www.cplusplus.com/reference/vector/vector/</a>
    </p>
    <p><a
        href="https://en.cppreference.com/w/cpp/container/vector">https://en.cppreference.com/w/cpp/container/vector</a>
    </p>
    <h2 id="-zadania-do-samodzielnego-wykonania-"> Zadania do samodzielnego wykonania </h2>
    <hr>
    <h3 id="-zadanie-1-wypenianie-i-wywietlanie-wektora"> Zadanie 1: wypenianie i wywietlanie wektora</h3>
    <p>Utw贸rz wektor liczb cakowitych o rozmiarze <strong>podanym przez u偶ytkownika</strong> w konsoli.</p>
    <p>Napisz dwie funkcje:</p>
    <ul>
      <li><code>fill_progressive</code>, kt贸ra wypeni przekazany do niej wektor kolejnymi liczbami cakowitymi od 1 do
        <code>n</code>, gdzie <code>n</code> to dugo wektora
      </li>
      <li><code>print_vector</code>, kt贸ra wywietli elementy wektora w konsoli, oddzielone przecinkami</li>
    </ul>
    <p>Przykadowo:</p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; vec(<span class="dv">6</span>);</span>
<span id="cb12-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb12-2" aria-hidden="true" tabindex="-1"></a>fill_progressive(vec);</span>
<span id="cb12-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb12-3" aria-hidden="true" tabindex="-1"></a>print_vector(vec);</span></code></pre>
    </div>
    <p>Wynik:</p>
    <pre><code>1, 2, 3, 4, 5, 6</code></pre>
    <hr>
    <h3 id="-zadanie-2-minmax"> Zadanie 2: min/max</h3>
    <p>Napisz funkcj <code>min_max</code> znajdujc minimum i maksimum w przekazanym do niej wektorze liczb typu
      <code>double</code>. Znalezione wartoci zwr贸 przez dwa argumenty-referencje:
    </p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> min;</span>
<span id="cb14-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> max;</span>
<span id="cb14-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; values = {-<span class="fl">1.0</span>, <span class="dv">100</span>, <span class="fl">3.14</span>, -<span class="fl">999.9</span>, <span class="fl">21.37</span>};</span>
<span id="cb14-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb14-5" aria-hidden="true" tabindex="-1"></a>min_max(values, min, max); <span class="co">// wpisze znalezione wartoci do zmiennych min i max</span></span></code></pre>
    </div>
    <hr>
    <h3 id="-zadanie-3-silnia"> Zadanie 3: silnia</h3>
    <p>Napisz funkcj <code>factorial</code>, kt贸ra wyznaczy silni z przekazanego argumentu <strong>bez u偶ycia
        rekurencji</strong>. Aby umo偶liwi operacje na du偶ych liczbach cakowitych wykorzystaj typ zmiennych
      <code>uint64_t</code>.
    </p>
    <p>Przykadowe wywoanie funkcji powinno wyglda nastpujco:</p>
    <div class="sourceCode" id="cb15">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint64_t</span> result = factorial(<span class="dv">15</span>);</span>
<span id="cb15-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; result &lt;&lt; <span class="bu">std::</span>endl; <span class="co">// wynik: 1307674368000</span></span></code></pre>
    </div>
    <hr>
    <h3 id="-zadanie-4-silnia-rekurencyjna"> Zadanie 4: silnia rekurencyjna</h3>
    <p>Napisz funkcj <code>factorial_r</code>, kt贸ra wyznaczy silni z przekazanego argumentu <strong>z u偶yciem
        rekurencji</strong>. Aby umo偶liwi operacje na du偶ych liczbach cakowitych wykorzystaj typ zmiennych
      <code>uint64_t</code>. Wykorzystaj definicj silni:
    </p>
    <p><img class="black-and-white" src="img/silnia.svg" alt="Silnia"></p>
    <p>Przykadowe wywoanie funkcji powinno wyglda nastpujco:</p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">uint64_t</span> result = factorial_r(<span class="dv">15</span>);</span>
<span id="cb16-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; result &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre>
    </div>
    <p>Wynik:</p>
    <pre><code>1307674368000</code></pre>
    <hr>
    <h3 id="-zadanie-5-liczby-pierwsze"> Zadanie 5: liczby pierwsze</h3>
    <p>Napisz funkcj <code>is_prime</code> sprawdzajc czy podana liczba jest liczb pierwsz (dzieli si bez reszty
      tylko przez 1 i siebie sam), tak aby mo偶na byo jej u偶y w poni偶szym przykadzie:</p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> prime_or_not_prime = <span class="dv">13</span>;</span>
<span id="cb18-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (is_prime(prime_or_not_prime)) {</span>
<span id="cb18-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; prime_or_not_prime &lt;&lt; <span class="st">" is prime!"</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb18-4" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb18-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout &lt;&lt; prime_or_not_prime &lt;&lt; <span class="st">" is not prime!"</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb18-6"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb18-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre>
    </div>
    <p>Jaki jest najwikszy potencjalny dzielnik, jaki warto sprawdza dla danej liczby?</p>
    <p>Nastpnie zapytaj u偶ytkownika o wprowadzenie zakresu (dolna i g贸rna granica) i wykorzystujc funkcj
      <code>is_prime</code> wywietl liczby pierwsze z 偶danego zakresu, np:
    </p>
    <pre><code>&gt; 1
&gt; 10
2 3 5 7</code></pre>
    <p>Zastan贸w si jak mo偶na przyspieszy przeszukiwanie zakresu - czy jakie liczby mo偶na atwo pomin?</p>
    <hr>
    <h3 id="-zadanie-6-wz贸r-na-"> Zadanie 6: wz贸r na </h3>
    <p>Szczeg贸lny przypadek szeregu naprzemiennego, zwany wzorem Leibniza, pozwala na wyznaczenie przybli偶enia liczby :
    </p>
    <p><img class="black-and-white" src="img/leibniz.svg" alt="Wz贸r Leibniza"></p>
    <p>Napisz funkcj <code>leibniz_pi</code>, kt贸ra obliczy  z zadan dokadnoci zadan w parametrze - sumuj wyrazy
      tak dugo, a偶 kolejny dodawany wyraz nie bdzie mniejszy ni偶 zadana dokadno. Mo偶esz por贸wna uzyskany wynik ze
      sta <code>M_PI</code> z nag贸wka <code>&lt;cmath&gt;</code>.</p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> stop_at = <span class="fl">0.001</span>;</span>
<span id="cb20-2"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> pi_approx = pi_leibniz(stop_at);</span>
<span id="cb20-3"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; pi_approx &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-5"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">"error: "</span> &lt;&lt; pi_approx - M_PI &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre>
    </div>
    <hr>
    <h3 id="-zadanie-7-rysowanie-kwadratu"> Zadanie 7: rysowanie kwadratu</h3>
    <p>Napisz funkcj <code>draw_square</code>, kt贸ra narysuje w konsoli pusty w rodku kwadrat o zadanym boku, zo偶ony
      ze znak贸w <code>#</code>:</p>
    <div class="sourceCode" id="cb21">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb21-1" aria-hidden="true" tabindex="-1"></a>draw_square(<span class="dv">4</span>);</span></code></pre>
    </div>
    <p>Wynik:</p>
    <pre><code>####
#  #
#  #
####</code></pre>
    <p>Nastpnie zmodyfikuj funkcj poprzez dodanie dw贸ch parametr贸w logicznych <code>left_diagonal</code> i
      <code>right_diagonal</code>. Ustawienie jednego z nich (bd藕 obu) na warto <code>true</code> powinno powodowa
      narysowanie wewntrz kwadratu odpowiednich przektnych, przykadowo:
    </p>
    <div class="sourceCode" id="cb23">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb23-1" aria-hidden="true" tabindex="-1"></a>draw_square(<span class="dv">6</span>, <span class="kw">true</span>, <span class="kw">false</span>);</span></code></pre>
    </div>
    <p>Wynik:</p>
    <pre><code>######
##   #
# #  #
#  # #
#   ##
######</code></pre>
    <div class="sourceCode" id="cb25">
      <pre
        class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="http://jug.put.poznan.pl/lab-psio/Lab%2001%20-%20Proste%20algorytmy,%20vector.html#cb25-1" aria-hidden="true" tabindex="-1"></a>draw_square(<span class="dv">7</span>, <span class="kw">true</span>, <span class="kw">true</span>);</span></code></pre>
    </div>
    <p>Wynik:</p>
    <pre><code>#######
##   ##
# # # #
#  #  #
# # # #
##   ##
#######</code></pre>
    <hr>
    <h3 id="-zadanie-8-nwd---algorytm-euklidesa"> Zadanie 8: NWD - algorytm Euklidesa</h3>
    <p>Algorytm Euklidesa pozwala znale藕 najwikszy wsp贸lny dzielnik dw贸ch liczb. Dla danych liczb <code>a</code> i
      <code>b</code> algorytm mo偶na opisa sownie jako:
    </p>
    <ol type="1">
      <li>oblicz <code>c</code> jako reszt z dzielenia <code>a</code> przez <code>b</code></li>
      <li>zastp <code>a</code> liczb <code>b</code>, nastpnie <code>b</code> liczb <code>c</code></li>
      <li>je偶eli warto <code>b</code> wynosi 0, to <code>a</code> jest szukan wartoci NWD, w przeciwnym wypadku
        przejd藕 do kroku 1</li>
    </ol>
    <p>Zastan贸w si jak przenie powy偶szy opis na mechanizmy (ptle, warunki) jzyka C++. Napisz funkcj
      <code>gcd(a, b)</code> implementujc opisany algorytm i zwracajc uzyskany wynik.
    </p>
    <hr>
    <p>Autorzy: <em>Jakub Tomczyski</em></p>
  </main>


</body>

</html>